# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Scalar on image regression
#'
#' A basis decomposition is used. The main coefficient beta follows STGP prior.
#' Kernel matrices need to be prespeficified
#'
#' @param Y The scalar outcome, n by 1
#' @param M The image predictor, n by p
#' @param X The scalar exposure variable, n by 1
#' @param C The q confounders, n by q
#' @param L_all A vector of length num_region, each element is an integer to indicate the number of basis in each region
#' @param num_region An integer, the total number of regions
#' @param region_idx A list object of length num_region, each element is a vector of
#' the indices of each voxel in that region. Note that this index starts from 0.
#' @param n_mcmc An integer to indicate the total number of MCMC iterations
#' @param K A list object of length num_region, the r-th element is a p_r by L_r matrix for the basis function
#' @param stop_burnin An integer to indicate from which iteration to stop burnin period.
#' Note that during burinin, the step size in MALA is adjusted every interval_step iterations.
#' @param start_joint An integer to indicate from which iteration to start join update all parameters.
#' Note that this function allows to update beta using MALA alone at the beginning.
#' Users may wait for a few iterations for beta to stabilize and then jointly update all other parameters (using Gibbs Sampling)
#' @param lambda A numeric variable to indicate the thresholding parameter lambda in STGP prior
#' @param target_accept_vec A vector of length num_region. Each element is a numeric variable in (0,1).
#' This allows the user to define different target acceptance rate for each region in the MALA algorithm,
#' and the step size will be adjusted to meet the target acceptance rate.
#' @param a A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}
#' @param b A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}
#' @param init A list object that contains the following element
#' \itemize{
#'   \item theta_beta A vector of length L. Initial value for theta_beta
#'   \item D A vector of length L. Eigenvalues for all regions in the basis
#'   \item gamma A numeric scalar, initial value for gamma
#'   \item cb A numeric scalar, initial value for the intercept term
#'   \item zetay A vector of length q, intial value for zetay
#'   \item sigma_Y A numeric scalar, intial value for sigma_Y
#'   \item sigma_beta A numeric scalar, initial value for sigma_beta
#' }
#' @param step A numeric vector of length num_region, the initial step size for each region
#' @param interval_step An integer to denote how often to update the step size
#' @param interval_thin An integer to denote how often to save the thinned MCMC sample for theta_beta
#' @param display_progress True for displaying progress bar
#' @useDynLib BIMA, .registration=TRUE
#' @import Rcpp
#' @export
#' @return A List object with the following component
#' \itemize{
#' \item theta_beta_mcmc_thin
#' \item logll_mcmc_Y
#' \item track_step
#' \item accept_block
#' \item emp_accept
#' \item gs A list object with the following component
#'   \itemize{
#'     \item zetay_mcmc
#'     \item cy_mcmc
#'     \item sigma_beta2_mcmc
#'     \item sigma_Y2_mcmc
#'   }
#' \item time_seg
#' \item timer
#' }
Y_regression_region_block_fast <- function(Y, M, X, C, L_all, num_region, region_idx, n_mcmc, K, stop_burnin, start_joint, lambda, target_accept_vec, a, b, init, step, interval_step, interval_thin, display_progress = TRUE) {
    .Call(`_UnconfoundedBIMA_Y_regression_region_block_fast`, Y, M, X, C, L_all, num_region, region_idx, n_mcmc, K, stop_burnin, start_joint, lambda, target_accept_vec, a, b, init, step, interval_step, interval_thin, display_progress)
}

#' Image on scalar regression with GP prior for alpha instead of STGP
#'
#' This is not a main function in BIMA package. It only provides an alternative to the STGP prior.
#' A basis decomposition is used. The main coefficient beta follows STGP prior.
#' Kernel matrices need to be prespeficified
#'
#' @param data A List that contains
#' \itemize{
#' \item M The image predictor, n by p
#' \item X The scalar exposure variable, n by 1
#' \item C The q confounders, n by q
#' }
#' @param region_idx_cpp A list object of length num_region, each element is a vector of
#' the indices of each voxel in that region. Note that this index starts from 0.
#' @param init A list object that contains the following element
#' \itemize{
#'   \item zetam A vector of length q, initial value for zetam
#'   \item sigma_alpha A numeric scalar, intial value for sigma_alpha
#'   \item sigma_M A numeric scalar, intial value for sigma_M
#'   \item theta_eta A n by L matrix, initial value for theta_eta
#'   \item sigma_eta A numeric scalar, intial value for sigma_eta
#'   \item theta_alpha A vector of length L, intial value for theta_alpha
#'   \item a A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}
#'   \item b A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}
#'   \item sigma_zetam A numeric scalar, intial value for sigma_zetam
#' }
#' @param kernel A List object
#' \itemize{
#'   \item D A list of length num_region, each element contains the eigen-values in one region
#'   \item Q A list of length num_region, each element contains the basis function (p_r by L_r) in one region
#' }
#' @param n_mcmc An integer to indicate the total number of MCMC iterations
#' @param display_progress True for displaying progress bar
#' @useDynLib BIMA, .registration=TRUE
#' @import Rcpp
#' @export
#' @return A list of
#' \itemize{
#'   \item theta_eta
#'   \item zetam_mcmc
#'   \item sigma_M2_inv_mcmc
#'   \item sigma_alpha2_inv_mcmc
#'   \item sigma_zetam2_inv_mcmc
#'   \item sigma_eta2_inv_mcmc
#'   \item logLL_mcmc
#'   \item Timer
#' }
M_regression_GS <- function(data, init, region_idx_cpp, kernel, n_mcmc, display_progress = TRUE) {
    .Call(`_UnconfoundedBIMA_M_regression_GS`, data, init, region_idx_cpp, kernel, n_mcmc, display_progress)
}

#' Image on scalar regression
#'
#' A basis decomposition is used. The main coefficient alpha follows STGP prior.
#' Kernel matrices need to be pre-speficified
#'
#' @param M The image predictor, n by p
#' @param X The scalar exposure variable, n by 1
#' @param C The q confounders, n by q
#' @param L_all A vector of length num_region, each element is an integer to indicate the number of basis in each region
#' @param num_region An integer, the total number of regions
#' @param region_idx A list object of length num_region, each element is a vector of
#' the indices of each voxel in that region. Note that this index starts from 0.
#' @param n_mcmc An integer to indicate the total number of MCMC iterations
#' @param K A list object of length num_region, the r-th element is a p_r by L_r matrix for the basis function
#' @param stop_burnin An integer to indicate from which iteration to stop burnin period.
#' Note that during burinin, the step size in MALA is adjusted every interval_step iterations.
#' @param lambda A numeric variable to indicate the thresholding parameter lambda in STGP prior
#' @param target_accept_vec A vector of length num_region. Each element is a numeric variable in (0,1).
#' This allows the user to define different target acceptance rate for each region in the MALA algorithm,
#' and the step size will be adjusted to meet the target acceptance rate.
#' @param a A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}
#' @param b A numeric variable for the Inverse-Gamma(a,b), priors for \eqn{\sigma^2_Y,\sigma^2_\beta}
#' @param init A list object that contains the following element
#' \itemize{
#'   \item theta_alpha A vector of length L. Initial value for theta_beta
#'   \item theta_zetam A L by q matrix. Initial value for theta_zetam
#'   \item theta_eta A matrix (L by n). Initial value for theta_eta
#'   \item D A vector of length L. Eigenvalues for all regions in the basis
#'   \item sigma_M A numeric scalar, initial value for gamma
#'   \item zetay A vector of length q, intial value for zetay
#'   \item sigma_alpha A numeric scalar, intial value for sigma_alpha
#'   \item sigma_eta A numeric scalar, initial value for sigma_eta
#' }
#' @param step A numeric vector of length num_region, the initial step size for each region
#' @param interval An integer to denote how often to update the step size
#' @param interval_eta An integer to denote how often to update theta_eta
#' @param thinning An integer to indicate how often to save the MCMC samples for theta_alpha
#' @param display_progress True for displaying progress bar
#' @import Rcpp
#' @useDynLib BIMA, .registration=TRUE
#' @export
#' @return A List object with the following component
#' \itemize{
#' \item theta_alpha_mcmc
#' \item logll_mcmc
#' \item track_step
#' \item accept_block
#' \item emp_accept
#' \item gs A list object with the following component
#'   \itemize{
#'     \item theta_zetam_mcmc
#'     \item sigma_M2_inv_mcmc
#'     \item sigma_alpha2_inv_mcmc
#'     \item sigma_eta2_inv_mcmc
#'   }
#' \item Timer
#' }
M_regression_region_block <- function(M, X, C, L_all, num_region, region_idx, n_mcmc, K, stop_burnin, lambda, target_accept_vec, init, interval, step, a = 1, b = 1, interval_eta = 10L, thinning = 10L, display_progress = TRUE) {
    .Call(`_UnconfoundedBIMA_M_regression_region_block`, M, X, C, L_all, num_region, region_idx, n_mcmc, K, stop_burnin, lambda, target_accept_vec, init, interval, step, a, b, interval_eta, thinning, display_progress)
}

